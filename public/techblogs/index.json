{
    "version" : "https://jsonfeed.org/version/1",
    "title" : "TechBlogs on Quality Tech Rider",
    "description": "Recent content in TechBlogs on Quality Tech Rider",
    "home_page_url" : "http://localhost:1313/",
    "feed_url" : "http://localhost:1313/techblogs/index.json",
    "items" : [
    {
        "title" : "Gatling",
        "date_published" : "2024-07-02T22:07:16+05:30",
        "date_modified" : "2024-07-02T22:07:16+05:30",
        "id" : "http://localhost:1313/techblogs/techblogs2/",
        "url" : "http://localhost:1313/techblogs/techblogs2/",
        "author" : {
          "name" : "Aravind Yamana"
        },
        "content_html" : "\u003cp\u003eHAR (Http Archive Resource)\u003c/p\u003e\n\u003cp\u003ehi\u003c/p\u003e\n"
    },
    {
        "title" : "Future of QA",
        "date_published" : "2023-01-20T08:00:00Z",
        "date_modified" : "2023-01-20T08:00:00Z",
        "id" : "http://localhost:1313/techblogs/futureoftesting/",
        "url" : "http://localhost:1313/techblogs/futureoftesting/",
        "content_html" : "\u003cp\u003eHi\u003c/p\u003e\n\u003cp\u003eThe future of software testing is being shaped by several emerging areas. Here\u0026rsquo;s a closer look at AI/ML Testing, Security Testing, and Performance Engineering and Load Testing:\u003c/p\u003e\n\u003ch2 id=\"1-aiml-testing\"\u003e1. AI/ML Testing\u003c/h2\u003e\n\u003cp\u003eArtificial Intelligence (AI) and Machine Learning (ML) are revolutionizing software testing by introducing automation and intelligent analysis.\u003c/p\u003e\n\u003ch3 id=\"test-automation\"\u003eTest Automation:\u003c/h3\u003e\n\u003cp\u003eAI can automate repetitive tasks, reducing the need for manual testing and increasing efficiency. AI-driven tools can generate test scripts, execute tests, and analyze results automatically.\u003c/p\u003e\n\u003ch3 id=\"intelligent-test-generation\"\u003eIntelligent Test Generation:\u003c/h3\u003e\n\u003cp\u003eML algorithms can analyze code changes and user behavior to predict the areas of an application most likely to contain defects, focusing testing efforts where they are needed most.\u003c/p\u003e\n\u003ch3 id=\"self-healing-tests\"\u003eSelf-healing Tests:\u003c/h3\u003e\n\u003cp\u003eAI can adapt to changes in the application UI, making test scripts more resilient to changes and reducing maintenance efforts.\u003c/p\u003e\n\u003ch3 id=\"defect-prediction\"\u003eDefect Prediction:\u003c/h3\u003e\n\u003cp\u003eAI can predict potential defects and prioritize testing based on historical data, reducing the time and effort required to identify issues.\u003c/p\u003e\n\u003ch2 id=\"2-security-testing\"\u003e2. Security Testing\u003c/h2\u003e\n\u003cp\u003eAs cyber threats become more sophisticated, security testing is increasingly critical.\u003c/p\u003e\n\u003cp\u003eShift-Left Security: Integrating security testing early in the development lifecycle ensures vulnerabilities are identified and addressed sooner. This approach, known as \u0026ldquo;shift-left\u0026rdquo; testing, helps in building secure software from the ground up.\nContinuous Security Testing: Implementing continuous integration/continuous deployment (CI/CD) pipelines with integrated security testing ensures that every code change is tested for security vulnerabilities.\nAdvanced Threat Simulation: Tools and techniques that simulate advanced threats can help identify vulnerabilities that traditional testing methods might miss.\nAI in Security Testing: AI can be used to detect unusual patterns and behaviors that might indicate a security breach, helping to prevent attacks in real-time.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003ePerformance Engineering and Load Testing\nEnsuring software performs well under various conditions is crucial for user satisfaction and business success.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eShift-Left Performance Testing: Just like security, performance testing is moving earlier in the development cycle to catch issues sooner.\nContinuous Performance Monitoring: Integrating performance testing into CI/CD pipelines allows for continuous monitoring and optimization of performance.\nScalability Testing: With the growing use of cloud services, testing for scalability to ensure applications can handle increasing loads without performance degradation is essential.\nAI in Performance Testing: AI can analyze performance data to identify patterns and predict potential performance issues before they occur.\u003c/p\u003e\n\u003ch1 id=\"conclusion-\"\u003eConclusion :\u003c/h1\u003e\n\u003cp\u003eThe future of software testing is being driven by advancements in AI/ML, increased focus on security, and the need for robust performance engineering. Adopting to these trends and learning the skills that are required would keep the testing jobs alive !\u003c/p\u003e\n"
    },
    {
        "title" : "Gatling",
        "date_published" : "2023-01-20T08:00:00Z",
        "date_modified" : "2023-01-20T08:00:00Z",
        "id" : "http://localhost:1313/techblogs/whatisgatling/",
        "url" : "http://localhost:1313/techblogs/whatisgatling/",
        "content_html" : "\u003cp\u003eGatling DSL (Domain-Specific Language) is a specialized programming language designed specifically for defining and running performance tests with Gatling, an open-source load testing tool. The DSL allows testers and developers to write expressive, concise, and readable performance test scenarios in Scala, which is the language Gatling is built on. The Gatling DSL abstracts much of the complexity involved in writing performance tests, making it easier to define scenarios, configure requests, and perform checks.\u003c/p\u003e\n\u003cp\u003eKey Features of Gatling DSL are\u003c/p\u003e\n\u003ch3 id=\"scenario-definition\"\u003eScenario Definition:\u003c/h3\u003e\n\u003cp\u003eDefine the sequence of HTTP requests and actions that simulate user behavior.\u003c/p\u003e\n\u003ch3 id=\"http-requests\"\u003eHTTP Requests:\u003c/h3\u003e\n\u003cp\u003eConfigure GET, POST, PUT, DELETE, and other HTTP requests.\u003c/p\u003e\n\u003ch3 id=\"checks\"\u003eChecks:\u003c/h3\u003e\n\u003cp\u003eValidate responses with assertions, such as checking status codes, response times, and specific data in the responses.\u003c/p\u003e\n\u003ch3 id=\"feeders\"\u003eFeeders:\u003c/h3\u003e\n\u003cp\u003eProvide dynamic data to the tests using feeders, which can read data from CSV files, JSON files, and other sources.\u003c/p\u003e\n\u003ch3 id=\"injection-profiles\"\u003eInjection Profiles:\u003c/h3\u003e\n\u003cp\u003eDefine how users are injected into the system over time, such as ramping up users gradually or starting with a burst of users.\u003c/p\u003e\n\u003ch3 id=\"reports\"\u003eReports:\u003c/h3\u003e\n\u003cp\u003eGenerate detailed and graphical reports of the test results, showing metrics like response times, request counts, and error rates.\u003c/p\u003e\n\u003cp\u003eExample of Gatling DSL\nHere\u0026rsquo;s a simple example to demonstrate the usage of the Gatling DSL:\u003c/p\u003e\n\u003ch2 id=\"heading\"\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport io.gatling.core.Predef._\nimport io.gatling.http.Predef._\n\nclass MySimulation extends Simulation {\n\n  // Define the HTTP protocol configuration\n  val httpProtocol = http\n\t.baseUrl(\u0026quot;http://example.com\u0026quot;) // Base URL for all requests\n\t.acceptHeader(\u0026quot;application/json\u0026quot;) // Default headers\n\t.userAgentHeader(\u0026quot;Gatling\u0026quot;)\n\n  // Define a feeder for dynamic data\n  val feeder = csv(\u0026quot;data/users.csv\u0026quot;).circular\n\n  // Define the scenario\n  val scn = scenario(\u0026quot;My Scenario\u0026quot;)\n\t.feed(feeder) // Use the feeder for dynamic data\n\t.exec(http(\u0026quot;Get User\u0026quot;)\n\t  .get(\u0026quot;/user/${userId}\u0026quot;) // Dynamic URL based on feeder data\n\t  .check(status.is(200)) // Check that the response status is 200\n\t  .check(jsonPath(\u0026quot;$.name\u0026quot;).is(\u0026quot;${userName}\u0026quot;)) // Check the JSON response\n\t)\n\n  // Set up the simulation with injection profile\n  setUp(\n\tscn.inject(\n\t  atOnceUsers(10), // Inject 10 users at once\n\t  rampUsers(100).during(10.seconds) // Ramp up to 100 users over 10 seconds\n\t).protocols(httpProtocol) // Use the HTTP protocol configuration\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExplanation\nHTTP Protocol Configuration: Sets the base URL and default headers for the HTTP requests.\nFeeder: Reads dynamic data from a CSV file to be used in the requests.\nScenario Definition: Defines a scenario named \u0026ldquo;My Scenario\u0026rdquo; that performs a GET request to /user/${userId}, where ${userId} is a placeholder for dynamic data from the feeder. The scenario includes checks to validate the response status and specific data in the JSON response.\nInjection Profile: Defines how users are injected into the simulation. In this example, 10 users are injected at once, and then 100 users are ramped up over 10 seconds.\nSimulation Setup: Sets up the simulation with the defined scenario and HTTP protocol configuration.\nBenefits of Gatling DSL\nReadability: The DSL makes it easy to read and understand performance test scenarios, even for those who are not familiar with Scala.\nExpressiveness: The DSL provides a rich set of features to express complex scenarios and checks concisely.\nReusability: Scenarios, feeders, and configurations can be reused across different tests, promoting code reuse and maintainability.\nExtensibility: Custom actions and checks can be implemented in Scala, allowing for advanced customization and extension of the DSL.\nThe Gatling DSL is a powerful tool that simplifies the creation and management of performance tests, enabling teams to effectively simulate and analyze user behavior under load.\u003c/p\u003e\n"
    },
    {
        "title" : "Request Headers and Response Headers",
        "date_published" : "2023-01-20T08:00:00Z",
        "date_modified" : "2023-01-20T08:00:00Z",
        "id" : "http://localhost:1313/techblogs/techblogs/",
        "url" : "http://localhost:1313/techblogs/techblogs/",
        "content_html" : "\u003ch2 id=\"what-are-request-headers\"\u003eWhat are Request Headers?\u003c/h2\u003e\n\u003cp\u003eIn simple terms additional meta-data sent by the client to server are called Request Headers , some of the main important request headers are as below .\u003c/p\u003e\n\u003ch2 id=\"1user-agent-\"\u003e1)User-Agent :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the client identity such as browser name, browser version,OS version etc.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"2connection-\"\u003e2)Connection :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the  State of connectivity between client and server , possibe values are {keep-alive;close}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"3accept-----\"\u003e3)Accept     :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the client prefernce format (eg .JSON,XML,HTML,XML,YAML etc) in which the server response to be sent to the client \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"4accept-lang\"\u003e4)Accept-Lang:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the client prefernce language (eg .EN-US,EN-IND,EN-GB etc) in which the server response to be sent to the client \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"5content-type\"\u003e5)Content-Type:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the type of content/format (eg.json,xml,html,yaml) which client vis sending the request body/payload to the server\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"6authorization-\"\u003e6)Authorization :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the user auth details to the server to establish the client identity to the server\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ok-now-lets-understand-what-are-response-headers\"\u003eOk, Now lets understand What are Response Headers\u003c/h2\u003e\n\u003cp\u003eIn simple terms additional meta-data sent by the server to client are called Response Headers , some of the main important request headers are as below\u003c/p\u003e\n\u003ch2 id=\"1user-agent--1\"\u003e1)User-Agent :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the client identity such as browser name, browser version,OS version etc.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"2connection--1\"\u003e2)Connection :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the  State of connectivity between client and server , possibe values are {keep-alive;close}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"3accept------1\"\u003e3)Accept     :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the client prefernce format (eg .JSON,XML,HTML,XML,YAML etc) in which the server response to be sent to the client \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"4accept-lang-1\"\u003e4)Accept-Lang:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the client prefernce language (eg .EN-US,EN-IND,EN-GB etc) in which the server response to be sent to the client \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"5content-type-1\"\u003e5)Content-Type:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the type of content/format (eg.json,xml,html,yaml) which client vis sending the request body/payload to the server\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"6authorization--1\"\u003e6)Authorization :\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eThis header reveals the user auth details to the server to establish the client identity to the server\u003c/code\u003e\u003c/pre\u003e\n"
    }
    ]
}
